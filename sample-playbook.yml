#
# Sample playbook demonstrating the various ways you can use the kubectl apply wrapper module.
#
# This playbook will create a test namespace and clean it up after execution.
---
- hosts: localhost
  gather_facts: false
  connection: local
  vars:
    # TODO: make ~/.kube/config the default used per k8s_raw
    kubeconfig_file: /home/dgoodwin/.kube/config
  tasks:
  - name: Create a namespace from inline yaml with kubeconfig file path
    kubectl:
      kubeconfig:
        # Kubeconfig file on the remote host:
        file: "{{ kubeconfig_file }}"
      namespace: testnamespace # TODO: required right now but redundant with definition
      # You can specify your kubernetes config inline if desired. The | is important here:
      definition: |
        kind: "Namespace"
        apiVersion: v1
        metadata:
          name: testnamespace
    register: ns_apply_reg

  - debug: var=ns_apply_reg

  - slurp:
      src: "{{ kubeconfig_file }}"
    register: kubeconfig_slurp

  - debug: msg="{{ kubeconfig_slurp['content'] | b64decode }}"

  # Use a kubeconfig and configmap definition from the local control host filesystem:
  - name: Create configmap with inline kubeconfig
    kubectl:
      kubeconfig:
        # Could also use a file lookup for any file on your control host:
        inline: "{{ kubeconfig_slurp['content'] | b64decode }}"
      namespace: testnamespace
      definition: "{{ lookup('file', 'configmap.yml') }}"
    register: ns_apply_reg

  - debug: var=ns_apply_reg

  # Transfer a file automatically, apply it, then clean it up:
  - name: Create configmap with inline kubeconfig and configmap files
    kubectl:
      kubeconfig:
        inline: "{{ kubeconfig_slurp['content'] | b64decode }}"
      namespace: testnamespace
      definition: "{{ lookup('file', 'files/configmap2.yml') }}"
    register: config2_reg

  #- debug: var=config2_reg

  #- name: Cleanup testnamespace
    #k8s_raw:
      #state: absent
      #kind: Namespace
      #name: testnamespace


